[
    {
        "label": "APIRouter",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "Depends",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "HTTPException",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "Query",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "FastAPI",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "AsyncSession",
        "importPath": "sqlalchemy.ext.asyncio",
        "description": "sqlalchemy.ext.asyncio",
        "isExtraImport": true,
        "detail": "sqlalchemy.ext.asyncio",
        "documentation": {}
    },
    {
        "label": "create_async_engine",
        "importPath": "sqlalchemy.ext.asyncio",
        "description": "sqlalchemy.ext.asyncio",
        "isExtraImport": true,
        "detail": "sqlalchemy.ext.asyncio",
        "documentation": {}
    },
    {
        "label": "async_sessionmaker",
        "importPath": "sqlalchemy.ext.asyncio",
        "description": "sqlalchemy.ext.asyncio",
        "isExtraImport": true,
        "detail": "sqlalchemy.ext.asyncio",
        "documentation": {}
    },
    {
        "label": "AsyncSession",
        "importPath": "sqlalchemy.ext.asyncio",
        "description": "sqlalchemy.ext.asyncio",
        "isExtraImport": true,
        "detail": "sqlalchemy.ext.asyncio",
        "documentation": {}
    },
    {
        "label": "create_async_engine",
        "importPath": "sqlalchemy.ext.asyncio",
        "description": "sqlalchemy.ext.asyncio",
        "isExtraImport": true,
        "detail": "sqlalchemy.ext.asyncio",
        "documentation": {}
    },
    {
        "label": "async_sessionmaker",
        "importPath": "sqlalchemy.ext.asyncio",
        "description": "sqlalchemy.ext.asyncio",
        "isExtraImport": true,
        "detail": "sqlalchemy.ext.asyncio",
        "documentation": {}
    },
    {
        "label": "AsyncSession",
        "importPath": "sqlalchemy.ext.asyncio",
        "description": "sqlalchemy.ext.asyncio",
        "isExtraImport": true,
        "detail": "sqlalchemy.ext.asyncio",
        "documentation": {}
    },
    {
        "label": "create_async_engine",
        "importPath": "sqlalchemy.ext.asyncio",
        "description": "sqlalchemy.ext.asyncio",
        "isExtraImport": true,
        "detail": "sqlalchemy.ext.asyncio",
        "documentation": {}
    },
    {
        "label": "async_sessionmaker",
        "importPath": "sqlalchemy.ext.asyncio",
        "description": "sqlalchemy.ext.asyncio",
        "isExtraImport": true,
        "detail": "sqlalchemy.ext.asyncio",
        "documentation": {}
    },
    {
        "label": "select",
        "importPath": "sqlalchemy.future",
        "description": "sqlalchemy.future",
        "isExtraImport": true,
        "detail": "sqlalchemy.future",
        "documentation": {}
    },
    {
        "label": "select",
        "importPath": "sqlalchemy.future",
        "description": "sqlalchemy.future",
        "isExtraImport": true,
        "detail": "sqlalchemy.future",
        "documentation": {}
    },
    {
        "label": "select",
        "importPath": "sqlalchemy.future",
        "description": "sqlalchemy.future",
        "isExtraImport": true,
        "detail": "sqlalchemy.future",
        "documentation": {}
    },
    {
        "label": "selectinload",
        "importPath": "sqlalchemy.orm",
        "description": "sqlalchemy.orm",
        "isExtraImport": true,
        "detail": "sqlalchemy.orm",
        "documentation": {}
    },
    {
        "label": "declarative_base",
        "importPath": "sqlalchemy.orm",
        "description": "sqlalchemy.orm",
        "isExtraImport": true,
        "detail": "sqlalchemy.orm",
        "documentation": {}
    },
    {
        "label": "relationship",
        "importPath": "sqlalchemy.orm",
        "description": "sqlalchemy.orm",
        "isExtraImport": true,
        "detail": "sqlalchemy.orm",
        "documentation": {}
    },
    {
        "label": "selectinload",
        "importPath": "sqlalchemy.orm",
        "description": "sqlalchemy.orm",
        "isExtraImport": true,
        "detail": "sqlalchemy.orm",
        "documentation": {}
    },
    {
        "label": "selectinload",
        "importPath": "sqlalchemy.orm",
        "description": "sqlalchemy.orm",
        "isExtraImport": true,
        "detail": "sqlalchemy.orm",
        "documentation": {}
    },
    {
        "label": "declarative_base",
        "importPath": "sqlalchemy.orm",
        "description": "sqlalchemy.orm",
        "isExtraImport": true,
        "detail": "sqlalchemy.orm",
        "documentation": {}
    },
    {
        "label": "Sentence",
        "importPath": "app.models",
        "description": "app.models",
        "isExtraImport": true,
        "detail": "app.models",
        "documentation": {}
    },
    {
        "label": "Token",
        "importPath": "app.models",
        "description": "app.models",
        "isExtraImport": true,
        "detail": "app.models",
        "documentation": {}
    },
    {
        "label": "Sentence",
        "importPath": "app.models",
        "description": "app.models",
        "isExtraImport": true,
        "detail": "app.models",
        "documentation": {}
    },
    {
        "label": "Token",
        "importPath": "app.models",
        "description": "app.models",
        "isExtraImport": true,
        "detail": "app.models",
        "documentation": {}
    },
    {
        "label": "Sentence",
        "importPath": "app.models",
        "description": "app.models",
        "isExtraImport": true,
        "detail": "app.models",
        "documentation": {}
    },
    {
        "label": "Token",
        "importPath": "app.models",
        "description": "app.models",
        "isExtraImport": true,
        "detail": "app.models",
        "documentation": {}
    },
    {
        "label": "new_session",
        "importPath": "app.database",
        "description": "app.database",
        "isExtraImport": true,
        "detail": "app.database",
        "documentation": {}
    },
    {
        "label": "create_tables",
        "importPath": "app.database",
        "description": "app.database",
        "isExtraImport": true,
        "detail": "app.database",
        "documentation": {}
    },
    {
        "label": "delete_tables",
        "importPath": "app.database",
        "description": "app.database",
        "isExtraImport": true,
        "detail": "app.database",
        "documentation": {}
    },
    {
        "label": "Base",
        "importPath": "app.database",
        "description": "app.database",
        "isExtraImport": true,
        "detail": "app.database",
        "documentation": {}
    },
    {
        "label": "PaginatedResponse",
        "importPath": "app.schemas",
        "description": "app.schemas",
        "isExtraImport": true,
        "detail": "app.schemas",
        "documentation": {}
    },
    {
        "label": "SentenceWithTokens",
        "importPath": "app.schemas",
        "description": "app.schemas",
        "isExtraImport": true,
        "detail": "app.schemas",
        "documentation": {}
    },
    {
        "label": "SentenceUpdate",
        "importPath": "app.schemas",
        "description": "app.schemas",
        "isExtraImport": true,
        "detail": "app.schemas",
        "documentation": {}
    },
    {
        "label": "TokenUpdate",
        "importPath": "app.schemas",
        "description": "app.schemas",
        "isExtraImport": true,
        "detail": "app.schemas",
        "documentation": {}
    },
    {
        "label": "SentenceCreate",
        "importPath": "app.schemas",
        "description": "app.schemas",
        "isExtraImport": true,
        "detail": "app.schemas",
        "documentation": {}
    },
    {
        "label": "SentenceResponse",
        "importPath": "app.schemas",
        "description": "app.schemas",
        "isExtraImport": true,
        "detail": "app.schemas",
        "documentation": {}
    },
    {
        "label": "asynccontextmanager",
        "importPath": "contextlib",
        "description": "contextlib",
        "isExtraImport": true,
        "detail": "contextlib",
        "documentation": {}
    },
    {
        "label": "start_import_data",
        "importPath": "import_data",
        "description": "import_data",
        "isExtraImport": true,
        "detail": "import_data",
        "documentation": {}
    },
    {
        "label": "router",
        "importPath": "app.routers.sentences",
        "description": "app.routers.sentences",
        "isExtraImport": true,
        "detail": "app.routers.sentences",
        "documentation": {}
    },
    {
        "label": "CORSMiddleware",
        "importPath": "fastapi.middleware.cors",
        "description": "fastapi.middleware.cors",
        "isExtraImport": true,
        "detail": "fastapi.middleware.cors",
        "documentation": {}
    },
    {
        "label": "Column",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "Integer",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "String",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "ForeignKey",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "JSON",
        "importPath": "sqlalchemy.types",
        "description": "sqlalchemy.types",
        "isExtraImport": true,
        "detail": "sqlalchemy.types",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "re",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "re",
        "description": "re",
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "logging",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "logging",
        "description": "logging",
        "detail": "logging",
        "documentation": {}
    },
    {
        "label": "json",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "json",
        "description": "json",
        "detail": "json",
        "documentation": {}
    },
    {
        "label": "asyncio",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "asyncio",
        "description": "asyncio",
        "detail": "asyncio",
        "documentation": {}
    },
    {
        "label": "parse",
        "importPath": "conllu",
        "description": "conllu",
        "isExtraImport": true,
        "detail": "conllu",
        "documentation": {}
    },
    {
        "label": "router",
        "kind": 5,
        "importPath": "app.routers.sentences",
        "description": "app.routers.sentences",
        "peekOfCode": "router = APIRouter()\nasync def get_paginated_sentences(page: int = 1, size: int = 10):\n    # Считаем общее количество предложений\n    async with new_session() as session:\n        result = await session.execute(select(Sentence))\n        sentences = result.scalars().all()  # Получаем все предложения\n        total_sentences = len(sentences)  # Используем len() для подсчета количества\n        # Вычисляем количество страниц\n        pages = (total_sentences + size - 1) // size\n        # Проверяем корректность страницы",
        "detail": "app.routers.sentences",
        "documentation": {}
    },
    {
        "label": "engine",
        "kind": 5,
        "importPath": "app.database",
        "description": "app.database",
        "peekOfCode": "engine = create_async_engine(\"sqlite+aiosqlite:///data/database.db\", echo=True)\nnew_session = async_sessionmaker(engine, expire_on_commit=False)\n# Создаем Base для наследования в моделях\nBase = declarative_base()\n# Избегаем циклического импорта\nasync def create_tables():\n    from app.models import Sentence, Token  # Импортируем модели здесь, чтобы избежать цикличности\n    async with engine.begin() as conn:\n        # Создаем все таблицы, зарегистрированные в Base\n        await conn.run_sync(Base.metadata.create_all)",
        "detail": "app.database",
        "documentation": {}
    },
    {
        "label": "new_session",
        "kind": 5,
        "importPath": "app.database",
        "description": "app.database",
        "peekOfCode": "new_session = async_sessionmaker(engine, expire_on_commit=False)\n# Создаем Base для наследования в моделях\nBase = declarative_base()\n# Избегаем циклического импорта\nasync def create_tables():\n    from app.models import Sentence, Token  # Импортируем модели здесь, чтобы избежать цикличности\n    async with engine.begin() as conn:\n        # Создаем все таблицы, зарегистрированные в Base\n        await conn.run_sync(Base.metadata.create_all)\nasync def delete_tables():",
        "detail": "app.database",
        "documentation": {}
    },
    {
        "label": "Base",
        "kind": 5,
        "importPath": "app.database",
        "description": "app.database",
        "peekOfCode": "Base = declarative_base()\n# Избегаем циклического импорта\nasync def create_tables():\n    from app.models import Sentence, Token  # Импортируем модели здесь, чтобы избежать цикличности\n    async with engine.begin() as conn:\n        # Создаем все таблицы, зарегистрированные в Base\n        await conn.run_sync(Base.metadata.create_all)\nasync def delete_tables():\n    async with engine.begin() as conn:\n        # Удаляем все таблицы",
        "detail": "app.database",
        "documentation": {}
    },
    {
        "label": "app",
        "kind": 5,
        "importPath": "app.main",
        "description": "app.main",
        "peekOfCode": "app = FastAPI(lifespan=lifespan)\n# Разрешённые источники (указывай фронтенд URL)\norigins = [\n    \"http://localhost:5173\",  # Vite React фронтенд\n    \"https://conllu-editor.vercel.app\",   # Альтернативный локальный адрес\n]\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=origins,  # Разрешённые источники\n    allow_credentials=True, # Разрешение отправки куки",
        "detail": "app.main",
        "documentation": {}
    },
    {
        "label": "origins",
        "kind": 5,
        "importPath": "app.main",
        "description": "app.main",
        "peekOfCode": "origins = [\n    \"http://localhost:5173\",  # Vite React фронтенд\n    \"https://conllu-editor.vercel.app\",   # Альтернативный локальный адрес\n]\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=origins,  # Разрешённые источники\n    allow_credentials=True, # Разрешение отправки куки\n    allow_methods=[\"*\"],    # Разрешить все HTTP-методы (GET, POST, PUT, DELETE и т.д.)\n    allow_headers=[\"*\"],    # Разрешить все заголовки",
        "detail": "app.main",
        "documentation": {}
    },
    {
        "label": "Sentence",
        "kind": 6,
        "importPath": "app.models",
        "description": "app.models",
        "peekOfCode": "class Sentence(Base):\n    __tablename__ = 'sentences'\n    id = Column(Integer, primary_key=True, index=True)\n    text = Column(String, index=True)  # Текст предложения\n    is_corrected = Column(Integer, default=0)  # 0 - не исправлено, 1 - исправлено\n    tokens = relationship(\"Token\", back_populates=\"sentence\")\nclass Token(Base):\n    __tablename__ = 'tokens'\n    id = Column(Integer, primary_key=True, index=True)\n    # Новое поле для хранения индекса токена в предложении, поддерживает диапазоны",
        "detail": "app.models",
        "documentation": {}
    },
    {
        "label": "Token",
        "kind": 6,
        "importPath": "app.models",
        "description": "app.models",
        "peekOfCode": "class Token(Base):\n    __tablename__ = 'tokens'\n    id = Column(Integer, primary_key=True, index=True)\n    # Новое поле для хранения индекса токена в предложении, поддерживает диапазоны\n    token_index = Column(String, index=True)  # Индекс токена в предложении (например, \"3-5\" или \"1\")\n    form = Column(String, index=True)  # Форма токена (например, слово)\n    lemma = Column(String)  # Лемма токена\n    pos = Column(String)  # Часть речи\n    xpos = Column(String)  # Точная часть речи\n    feats = Column(JSON)  # Характеристики токена (например, морфологические признаки)",
        "detail": "app.models",
        "documentation": {}
    },
    {
        "label": "SentenceResponse",
        "kind": 6,
        "importPath": "app.schemas",
        "description": "app.schemas",
        "peekOfCode": "class SentenceResponse(BaseModel):\n    id: int\n    text: str\n    is_corrected: int\n    class Config:\n        orm_mode = True\nclass PaginatedResponse(BaseModel):\n    total: int\n    pages: int\n    page: int",
        "detail": "app.schemas",
        "documentation": {}
    },
    {
        "label": "PaginatedResponse",
        "kind": 6,
        "importPath": "app.schemas",
        "description": "app.schemas",
        "peekOfCode": "class PaginatedResponse(BaseModel):\n    total: int\n    pages: int\n    page: int\n    size: int\n    items: List[SentenceResponse]\n#для получания предложения с токенами\nclass TokenBase(BaseModel):\n    id: int\n    token_index: Optional[str]",
        "detail": "app.schemas",
        "documentation": {}
    },
    {
        "label": "TokenBase",
        "kind": 6,
        "importPath": "app.schemas",
        "description": "app.schemas",
        "peekOfCode": "class TokenBase(BaseModel):\n    id: int\n    token_index: Optional[str]\n    form: str\n    lemma: Optional[str] = None\n    pos: Optional[str] = None\n    xpos: Optional[str] = None\n    feats: Optional[dict] = None\n    head: Optional[int] = None\n    deprel: Optional[str] = None",
        "detail": "app.schemas",
        "documentation": {}
    },
    {
        "label": "SentenceWithTokens",
        "kind": 6,
        "importPath": "app.schemas",
        "description": "app.schemas",
        "peekOfCode": "class SentenceWithTokens(BaseModel):\n    id: int\n    text: str\n    is_corrected: int\n    tokens: List[TokenBase]\n    class Config:\n        orm_mode = True\nclass TokenUpdate(BaseModel):\n    id: Optional[int] = None\n    form: Optional[str]",
        "detail": "app.schemas",
        "documentation": {}
    },
    {
        "label": "TokenUpdate",
        "kind": 6,
        "importPath": "app.schemas",
        "description": "app.schemas",
        "peekOfCode": "class TokenUpdate(BaseModel):\n    id: Optional[int] = None\n    form: Optional[str]\n    lemma: Optional[str]\n    pos: Optional[str]\n    xpos: Optional[str]\n    feats: Optional[dict]\n    head: Optional[int]\n    deprel: Optional[str]\n    misc: Optional[str]",
        "detail": "app.schemas",
        "documentation": {}
    },
    {
        "label": "SentenceUpdate",
        "kind": 6,
        "importPath": "app.schemas",
        "description": "app.schemas",
        "peekOfCode": "class SentenceUpdate(BaseModel):\n    text: Optional[str]\n#для создание\nclass TokenCreate(BaseModel):\n    form: str\n    lemma: str\n    pos: str\n    xpos: str\n    feats: Optional[dict] = None\n    head: int",
        "detail": "app.schemas",
        "documentation": {}
    },
    {
        "label": "TokenCreate",
        "kind": 6,
        "importPath": "app.schemas",
        "description": "app.schemas",
        "peekOfCode": "class TokenCreate(BaseModel):\n    form: str\n    lemma: str\n    pos: str\n    xpos: str\n    feats: Optional[dict] = None\n    head: int\n    deprel: str\n    misc: Optional[str] = None\nclass SentenceCreate(BaseModel):",
        "detail": "app.schemas",
        "documentation": {}
    },
    {
        "label": "SentenceCreate",
        "kind": 6,
        "importPath": "app.schemas",
        "description": "app.schemas",
        "peekOfCode": "class SentenceCreate(BaseModel):\n    text: str\n    is_corrected: int\n    tokens: List[TokenCreate]\nclass SentenceResponse(BaseModel):\n    id: int\n    text: str\n    class Config:\n        orm_mode = True",
        "detail": "app.schemas",
        "documentation": {}
    },
    {
        "label": "SentenceResponse",
        "kind": 6,
        "importPath": "app.schemas",
        "description": "app.schemas",
        "peekOfCode": "class SentenceResponse(BaseModel):\n    id: int\n    text: str\n    class Config:\n        orm_mode = True",
        "detail": "app.schemas",
        "documentation": {}
    },
    {
        "label": "isHead",
        "kind": 2,
        "importPath": "clearconllu",
        "description": "clearconllu",
        "peekOfCode": "def isHead(token: str) -> bool:\n    \"\"\" Проверяет, является ли токен допустимым значением HEAD в CoNLL-U. \"\"\"\n    return token.isdigit() and int(token) >= 0\ndef isDeprel(token: str) -> bool:\n    \"\"\" Проверяет, является ли токен допустимым значением DEPREL в CoNLL-U. \"\"\"\n    VALID_DEPREL = {\n        \"root\", \"nsubj\", \"obj\", \"iobj\", \"csubj\", \"ccomp\", \"xcomp\", \"advcl\", \"obl\",\n        \"vocative\", \"discourse\", \"conj\", \"cc\", \"case\", \"det\", \"amod\", \"nmod\",\n        \"appos\", \"nummod\", \"acl\", \"compound\", \"punct\", 'cop', 'aux', 'parataxis', \"punct\", \"det\"\n    }",
        "detail": "clearconllu",
        "documentation": {}
    },
    {
        "label": "isDeprel",
        "kind": 2,
        "importPath": "clearconllu",
        "description": "clearconllu",
        "peekOfCode": "def isDeprel(token: str) -> bool:\n    \"\"\" Проверяет, является ли токен допустимым значением DEPREL в CoNLL-U. \"\"\"\n    VALID_DEPREL = {\n        \"root\", \"nsubj\", \"obj\", \"iobj\", \"csubj\", \"ccomp\", \"xcomp\", \"advcl\", \"obl\",\n        \"vocative\", \"discourse\", \"conj\", \"cc\", \"case\", \"det\", \"amod\", \"nmod\",\n        \"appos\", \"nummod\", \"acl\", \"compound\", \"punct\", 'cop', 'aux', 'parataxis', \"punct\", \"det\"\n    }\n    return token in VALID_DEPREL\ndef fix_conllu_line(line):\n    # Разделяем строку на колонки по табуляции",
        "detail": "clearconllu",
        "documentation": {}
    },
    {
        "label": "fix_conllu_line",
        "kind": 2,
        "importPath": "clearconllu",
        "description": "clearconllu",
        "peekOfCode": "def fix_conllu_line(line):\n    # Разделяем строку на колонки по табуляции\n    #columns = re.split(r'\\s+', line.strip())  # Разделение по пробелам и табуляциям\n    columns = line.strip().split(\"\\t\")\n    try:\n        if len(columns) < 10:\n            columns += [\"_\"] * (10 - len(columns))\n        # Если строка имеет больше 10 колонок, удаляем лишние\n        if len(columns) > 10:\n            # Перед удалением лишних колонок проверяем, если значение не равно \"_\", выводим sent_id",
        "detail": "clearconllu",
        "documentation": {}
    },
    {
        "label": "correct_conllu_file",
        "kind": 2,
        "importPath": "clearconllu",
        "description": "clearconllu",
        "peekOfCode": "def correct_conllu_file(input_file_path, output_file_path):\n    with open(input_file_path, \"r\", encoding=\"utf-8\") as f:\n        lines = f.readlines()\n    corrected_lines = []\n    for line in lines:\n        # Пропускаем комментарии и пустые строки\n        if line.startswith(\"#\") or not line.strip():\n            corrected_lines.append(line.strip())\n        else:\n            corrected_line = fix_conllu_line(line)",
        "detail": "clearconllu",
        "documentation": {}
    },
    {
        "label": "input_file",
        "kind": 5,
        "importPath": "clearconllu",
        "description": "clearconllu",
        "peekOfCode": "input_file = \"data/mydata_corrected_3.conllu\"  # Путь к исходному файлу\noutput_file = \"data/mydata_corrected_3.conllu\"  # Путь к исправленному файлу\ncorrect_conllu_file(input_file, output_file)\nprint(\"Файл успешно исправлен!\")",
        "detail": "clearconllu",
        "documentation": {}
    },
    {
        "label": "output_file",
        "kind": 5,
        "importPath": "clearconllu",
        "description": "clearconllu",
        "peekOfCode": "output_file = \"data/mydata_corrected_3.conllu\"  # Путь к исправленному файлу\ncorrect_conllu_file(input_file, output_file)\nprint(\"Файл успешно исправлен!\")",
        "detail": "clearconllu",
        "documentation": {}
    },
    {
        "label": "DATABASE_URL",
        "kind": 5,
        "importPath": "db_to_conllu",
        "description": "db_to_conllu",
        "peekOfCode": "DATABASE_URL = \"sqlite+aiosqlite:///data/database.db\"\nengine = create_async_engine(DATABASE_URL, echo=False)\nnew_session = async_sessionmaker(engine, expire_on_commit=False)\nasync def convert_to_conllu(session: AsyncSession, output_file: str):\n    async with session.begin():\n        result = await session.execute(select(Sentence).options(selectinload(Sentence.tokens)))\n        sentences = result.scalars().all()\n    conllu_lines = []\n    for sentence in sentences:\n        conllu_lines.append(f\"# sent_id = {sentence.id}\")",
        "detail": "db_to_conllu",
        "documentation": {}
    },
    {
        "label": "engine",
        "kind": 5,
        "importPath": "db_to_conllu",
        "description": "db_to_conllu",
        "peekOfCode": "engine = create_async_engine(DATABASE_URL, echo=False)\nnew_session = async_sessionmaker(engine, expire_on_commit=False)\nasync def convert_to_conllu(session: AsyncSession, output_file: str):\n    async with session.begin():\n        result = await session.execute(select(Sentence).options(selectinload(Sentence.tokens)))\n        sentences = result.scalars().all()\n    conllu_lines = []\n    for sentence in sentences:\n        conllu_lines.append(f\"# sent_id = {sentence.id}\")\n        conllu_lines.append(f\"# text = {sentence.text}\")",
        "detail": "db_to_conllu",
        "documentation": {}
    },
    {
        "label": "new_session",
        "kind": 5,
        "importPath": "db_to_conllu",
        "description": "db_to_conllu",
        "peekOfCode": "new_session = async_sessionmaker(engine, expire_on_commit=False)\nasync def convert_to_conllu(session: AsyncSession, output_file: str):\n    async with session.begin():\n        result = await session.execute(select(Sentence).options(selectinload(Sentence.tokens)))\n        sentences = result.scalars().all()\n    conllu_lines = []\n    for sentence in sentences:\n        conllu_lines.append(f\"# sent_id = {sentence.id}\")\n        conllu_lines.append(f\"# text = {sentence.text}\")\n        tokens = sentence.tokens",
        "detail": "db_to_conllu",
        "documentation": {}
    },
    {
        "label": "engine",
        "kind": 5,
        "importPath": "import_data",
        "description": "import_data",
        "peekOfCode": "engine = create_async_engine(\"sqlite+aiosqlite:///data/database.db\", echo=False)\nnew_session = async_sessionmaker(engine, expire_on_commit=False)\nasync def load_conllu_to_db(file_path: str, session: AsyncSession):\n    with open(file_path, \"r\", encoding=\"utf-8\") as f:\n        data = f.read()\n    sentences = parse(data)\n    for sent in sentences:\n        sentence_text = \" \".join([token[\"form\"] for token in sent])\n        db_sentence = Sentence(text=sentence_text, is_corrected=0)\n        session.add(db_sentence)",
        "detail": "import_data",
        "documentation": {}
    },
    {
        "label": "new_session",
        "kind": 5,
        "importPath": "import_data",
        "description": "import_data",
        "peekOfCode": "new_session = async_sessionmaker(engine, expire_on_commit=False)\nasync def load_conllu_to_db(file_path: str, session: AsyncSession):\n    with open(file_path, \"r\", encoding=\"utf-8\") as f:\n        data = f.read()\n    sentences = parse(data)\n    for sent in sentences:\n        sentence_text = \" \".join([token[\"form\"] for token in sent])\n        db_sentence = Sentence(text=sentence_text, is_corrected=0)\n        session.add(db_sentence)\n        await session.flush()  # Получаем ID для предложения",
        "detail": "import_data",
        "documentation": {}
    },
    {
        "label": "look__line",
        "kind": 2,
        "importPath": "lookfile",
        "description": "lookfile",
        "peekOfCode": "def look__line(line, metadata):\n    columns = line.strip().split(\"\\t\")\n    if len(columns) < 10:\n        columns += [\"_\"] * (10 - len(columns))\n    if columns[6] == \"punct\":\n        print(columns, metadata)\ndef look_file(input_file_path):\n    with open(input_file_path, \"r\", encoding=\"utf-8\") as f:\n        lines = f.readlines()  \n        metadata = ''",
        "detail": "lookfile",
        "documentation": {}
    },
    {
        "label": "look_file",
        "kind": 2,
        "importPath": "lookfile",
        "description": "lookfile",
        "peekOfCode": "def look_file(input_file_path):\n    with open(input_file_path, \"r\", encoding=\"utf-8\") as f:\n        lines = f.readlines()  \n        metadata = ''\n    for line in lines:\n        if line.startswith(\"#\"):\n            metadata = line\n            continue\n        look__line(line=line, metadata=metadata)\n# Пример использования",
        "detail": "lookfile",
        "documentation": {}
    },
    {
        "label": "input_file",
        "kind": 5,
        "importPath": "lookfile",
        "description": "lookfile",
        "peekOfCode": "input_file = \"data/mydata_corrected_3.conllu\"  # Путь к исходному файлу\nlook_file(input_file)",
        "detail": "lookfile",
        "documentation": {}
    }
]